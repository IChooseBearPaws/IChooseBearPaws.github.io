<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/style.css">
<div class="limite">
<div class="box">
	<title>My algorithmic learning home page! <br /> </title>
</head>
    <h1>Welcome to my algorithmic learning home page!</h1>
<body>
<pre1>我的Github : <a href = "https://github.com/IChooseBearPaws/" target = "_blank"> My Github </a></pre1><br />
<pre2>我的LeetCode : <a href = "https://leetcode-cn.com/u/allac_1/" target = "_blank"> My Leetcode </a></pre2> <br /><br />
<day>  2020 年 12 月 10 日</day> <br />
<merge>Merge sort (Divide and conquer algorithm) </merge><br />
<pre6>归并排序 动画展示: <a href = "https://www.bilibili.com/video/BV1AJ41167VK?from=search&seid=2883332805467242330/" target = "_blank">访问动画</a><br /></pre6>
<div class="boxx">
<pre5>代码: </pre5>
    <strong>#pragma once
    template &lt;class T&gt;
<pre>
    void Meragesort(T * arr, int left, int right) {
        if (left == righ) return;
        int mid = (left + right) / 2;
        Meragesort(arr, left, mid);       // 左排序
        Meragesort(arr, mid + 1, right); //右排序 <br />
        int ret[right - left + 1];
        int begin = left, end = mid + 1;
        int index = 0;
        while (begin &lt;= left || end &lt;= right) {
            if (begin &gt; left) ret[index++] = arr[right++];
            else if (end &gt; right) ret[index++] = arr[left++];
            else if (arr[begin] &lt; arr[left]) ret[index++] = arr[begin++];
                else ret[index++] = arr[end++];
        }
        int index_ = 0;
        for (int i = left, i &lt;= right; ++i) arr[i] = ret[index_++];
    }</strong><pre>
    </div>
<pre3>
原理: <br />1.利用分治算法, 将数组 arr[] 形成两个序列 arr_1(n / 2) 和 arr_2(n / 2)一直递归分解, 直到每个序列只包含一个 / 两个元素<br />
       	2.形成两个数组a[], b[], 对两个数组的第一个元素进行比较, 较小的放到临时创建的数组 buff[] 中, 当其中一个数组 a[] / b[] 已经将所有元素放入了 buff[]中,
          那么将剩下没有放完的数组 (b[] / a[]) 的剩余元素依次放进 buff[] 数组中去.<br />
	 3.重复第二步 直到排序完毕.<br />
    <pre>算法分析:
	   假设n > 1 : 时间是T(n) 那么两个就是 2T(2 / n) 合并算法时间是 O(n)   n = 1 : O(1).
	   根据主定理 : T(n) = kT(n / m) + f(n)中, f(n) = n ^ d, d >= 0
	   则 时间复杂度是 O(nlogn).(出自视频 <a href = "https://www.bilibili.com/video/BV1GT4y1G75V/" target = "_blank">归并视频及时间复杂度</a></pre>

<pre>总结:   归并排序是一种非就地排序，将需要与待排序序列一样多的辅助空间。在使用它对两个己有序的序列归并，将有无比的优势。
	其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlog2n).
	对数据的有序性不敏感。若数据节点数据量大，那将不适合。
	但可改造成索引操作，效果将非常出色。(出CSDN @会飞的鱼_fly <a href = "https://blog.csdn.net/u011244839/article/details/69959943/" target = "_blank"> emragesort优点 </a> <br /></pre>
</pre3>
<pre6> 2021 年 1 月 17 日 </pre6> <br />
<pre6>//  Union Find <br />
//并查集动画 :  <a href = "https://www.bilibili.com/video/BV1yE411u7FD?p=21" target = "_blank"> 并查集动画 </a><br />
//并查集讲解:   <a href = "https://www.bilibili.com/video/BV1qK411J7J6?from=search&seid=14834253158345534002" target = "_blank"> 并查集教学 </a> <br />
// 并查集是 用于关于图的两个结点连通性问题 一个很经典的一个解法
// 代码可读性高, 时间复杂度只有 O(1), 空间复杂度 O(n); </pre6>
<strong><pre>
    <div class="boxx">
    class UF {
    private:
        vector&lt;int> par;
    public:
        UF(int n) : par(n) {
            for (int i = 0; i &lt; n; ++i) {
                par[i] = i;
            }
        }

        int find(int x) {
            return par[x] = x == par[x] ? x : find(par[x]);
        }

        // 对于 union find的 find函数 最初的写法 有 return x == par[x] ? x : find(par[x]); 
           如果是这样查询 那么最坏的结果是查询一个链表 
        // 他的时间复杂度将会是 O(n), 而 如果写成 return par[x] = x == par[x] ? x : find(par[x]); 
           那么 他将变成 一棵深度为二的一棵树, 
        // 那么 当第二次查询的时候 他的时间复杂度 可以降到 O(1)

        void merge(int x, int y) {
            int fx = find(x), fy = find(y);
            if (find(x) != find(y)) {
                par[find(y)] = find(x);
            }
        }
    };</strong> </div>
<pre6>
//以上就是 关于并查集 Union Find 的基本模板

//关于 Union Find 例题 (来自于 Leetcode 684 冗余连接(mid)) <a href = "https://leetcode-cn.com/classic/problems/redundant-connection/description/" target = "_blank"> 冗余连接 </a>
	//输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。
	//结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u &lt; v，表示连接顶点u 和v的无向图的边。
	//返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边[u, v] 应满足相同的格式 u &lt; v。
</pre6>

<pre6>2021 年 2 月 17 日</pre6>
<pre6>字典树教学: <a href = "https://www.bilibili.com/video/BV1Az4y1S7c7?from=search&seid=7439230436454907529" target="_blank"> 字典树 </a> <br/>
字典树模板</pre6>
<div class="boxx">
<strong>  class Trie {
    public:
        /** Initialize your data structure here. */
        Trie() : root_(new TrieNode()) {}

        /** Inserts a word into the trie. */
        void insert(string word) {
            TrieNode* p = root_.get();
            for (char c : word) {
                if (!p->child[c - 'a'])
                    p->child[c - 'a'] = new TrieNode();
                p = p->child[c - 'a'];
            }
            p->is_word = true;
        }

        /** Returns if the word is in the trie. */
        bool search(string word) {
            TrieNode* p = find(word);
            return p &amp;&amp; p->is_word;
        }

        /** Returns if there is any word in the trie that starts with the given prefix. */
        bool startsWith(string prefix) {
            return find(prefix) != nullptr;
        }
    private:
        class TrieNode {
        public:
            TrieNode() : is_word(false), child(26, nullptr) {}
            ~TrieNode() {
                for (TrieNode* p : child) {
                    if (p) delete p;
                }
            }
            vector &lt;TrieNode*&gt; child;
            bool is_word;   // 代表他是一个完整的单词(true) 否则不然
        };

        TrieNode* find(const string&amp; prefix) {
            TrieNode* p = root_.get();
            for (auto charr : prefix) {
                p = p->child[charr - 'a'];
                if (nullptr == p) break;
            }
            return p;
        }
        std::unique_ptr&lt;TrieNode&gt; root_;  //智能指针 可以自动析构
    };</pre> </strong> </div>
    </div>
</div>
</body>
</html>
